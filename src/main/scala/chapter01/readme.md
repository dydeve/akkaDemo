### 初识akka

#### 什么是actor模型

`对象`的属性被并发读取、修改时，会产生竞态(race condition)，所以需要同步加锁。这是不可避免的，因为java`共享内存`。

`Actor`和对象不同之处，Actor只能通过`消息传递`与外界通信。`消息传递`可理解为actor发消息、收消息、回复消息。消息传递是异步的，actor对外部没有依赖，这与方法调用不同。

Actor 每次只同步处理一个消息。邮箱本质上是等待 Actor 处理的一个工作队列

```text
message ---> mailbox ---> actor
```

名词解释：
- Actor:一个表示工作节点的并发原语，同步处理接收到的消息。Actor 可以保存并修改内部状态。

- 消息:用于跨进程(比如多个`Actor`之间)通信的数据。
 
- 消息传递:一种软件开发范式，通过传递消息来触发各种行为，而不是直接触发行为。

- 邮箱地址:消息传递的目标地址，当 Actor 空闲时会从该地址获取消息进行处理。

- 邮箱:在 Actor 处理消息前具体存储消息的地方。可以将其看作是一个消息队列。

- Actor 系统:多个 Actor 的集合以及这些 Actor 的邮箱地址、邮箱和配置等。

actor优点：

1. 每个actor各司其职，使用 Actor 模型分析并发事件非常容易

2. 消除共享状态。状态可变时，不容易在测试中发现bug，并发运行时容易产生bug。因为一个 Actor 每次只处理一条消息，所以可以在 Actor 内部安全地保存状态.

#### 监督和容错机制
Actor模型通过监督机制来提供容错性。Actor可以负责监督它的子Actor，监控子Actor的运行错误，并且根据子Actor生命周期中的运行表现执行相应的操作。

当Actor发生错误时，监督机制提供的默认处理方式是重新启动发生错误的Actor(实际上是重新创建)。
这种处理方式基于一种假设:意外发生的错误是由错误状态导致的，因此移除并重新创建应用程序中出错的部分可以将其修复，并恢复正常工作。我们也可以**编写自定义的错误处理方式作为监督策略**，
这样基本上就可以采取任何操作将应用程序恢复至工作状态

#### 分布式与位置透明
Akka将其自己视作是一个`支持容错性的分布式工具集`。也就是说，Akka是一个`提供了在多个服务器的物理边界之间工作的工具集`。在支持 高可用性的同时，几乎可以无限扩展。
`Akka Cluster`(集群)允许将一个Actor系统部署到多台机器上，并且这一点对用户不可见。`Akka IO`和`Akka HTTP`也已经进入了核心库，使得系统之间的交互变得更简单。

Akka 对于 Actor 模型的重要贡献之一就是`位置透明性`的概念:就是说一个 Actor 的邮箱地址实际上可以是一个远程地址，但是这个地址对 开发者来说基本上是透明的，所以无论是否是远程地址，编写的代码也基本上是相同的。


Akka 添加了远程处理以及位置透明性，使得一个 Actor 的邮箱可以在远程机器上，而 Akka 会对网络上的消息传输进行抽象封装。

Akka也实现了`reactive stream`，支持用于异步处理的`非阻塞背压`(Back-Pressure)